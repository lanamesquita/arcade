{
    "title": "@c019recursividade: @c019recursividade",
    "description": "# @c019recursividade\n\nDescri\u00e7\u00e3o no c\u00f3digo.\n\n[C\u00f3digo](https://github.com/qxcodefup/arcade/blob/master/base/c019recursividade/.cache/draft.c)\n\n## Testes\n\n```py\n>>>>>>>> INSERT\n======== EXPECT\nO fatorial de 5 \u00e9 120.\n\n<<<<<<<< FINISH\n```\n",
    "upload": [
        {
            "name": "vpl_evaluate.cases",
            "contents": ">>>>>>>> INSERT\n======== EXPECT\nO fatorial de 5 \u00e9 120.\n\n<<<<<<<< FINISH\n\n",
            "type": "hide"
        }
    ],
    "draft": {
        "c": [
            {
                "name": "main.c",
                "contents": "#include <stdio.h>\n\n// Agora, sobre recurs\u00e3o, precisamos ter muita calma e cuidado ao implementa-la.\n// A recurs\u00e3o permite que uma fun\u00e7\u00e3o se chame novamente dentro de si mesma, com uma condi\u00e7\u00e3o para interromper o ciclo.\n// No exemplo abaixo, a fun\u00e7\u00e3o `fatorial` calcula o fatorial de um n\u00famero.\n// Quando `n` \u00e9 0, a fun\u00e7\u00e3o simplesmente retorna 1, pois 0! (fatorial de 0) \u00e9 1.\n// Caso contr\u00e1rio, a fun\u00e7\u00e3o multiplica `n` pelo resultado de `fatorial(n-1)`,\n// chamando a si mesma at\u00e9 que `n` chegue a 0 e comece a voltar com os resultados das multiplica\u00e7\u00f5es.\n\n//DEL!\nint fatorial(int n) {\n    // Condi\u00e7\u00e3o de parada: quando `n` chega a 0, retornamos 1\n    if (n == 0) {\n        //Lembre que se cair nesse retorno, a fun\u00e7\u00e3o acaba aqui e o compilador n\u00e3o l\u00ea o que tem abaixo.\n        return 1;\n    }\n    // Caso contr\u00e1rio, multiplicamos `n` pelo resultado de `fatorial(n - 1)'\n    return n * fatorial(n - 1); // Empilha a chamada de `fatorial(n - 1)` e multiplica o valor de `n` por essa chamada ao desempilhar\n}\n// A fun\u00e7\u00e3o vai se chamando, empilhando chamadas dela mesmo e incrementando valor na variavel, mas quando o n chegar em 0, ela cai no primeiro caso e retorna 1.\n//ACT!\n// //TODO: corrija a fun\u00e7\u00e3o recursiva fatorial abaixo:\n// int fatorial(int n) {\n//     // Condi\u00e7\u00e3o de parada: quando `n` chega a 0, retornamos 1\n//     if (n == ???) {\n//         //Lembre que se cair nesse retorno, a fun\u00e7\u00e3o acaba aqui e o compilador n\u00e3o l\u00ea o que tem abaixo.\n//         return ???;\n//     }\n//     // Caso contr\u00e1rio, multiplicamos `n` pelo resultado de `fatorial(n - 1)', chamando a fun\u00e7\u00e3o novamente, dentro dela\n//     return n * ???(n - 1); // Empilha a chamada de `fatorial(n - 1)` e multiplica o valor de `n` por essa chamada ao desempilhar\n// }\n// // A fun\u00e7\u00e3o vai se chamando, empilhando chamadas dela mesmo e incrementando valor na variavel, mas quando o n chegar em 0, ela cai no primeiro caso e retorna 1.\n//ADD!\n\nint main() {\n    int numero = 5;\n    // Chamamos a fun\u00e7\u00e3o `fatorial` e armazenamos o resultado\n    int resultado = fatorial(numero);\n    printf(\"O fatorial de %d \u00e9 %d.\\n\", numero, resultado);\n\n    return 0;\n}\n",
                "type": "show"
            }
        ]
    }
}
